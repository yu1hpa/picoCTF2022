# Very-Smooth

### Solution
First, we try [factordb](http://factordb.com/), but this dosen't work.
so now look at how to make $p$ and $q$.
there is `DEGUB` in ``gen.py``, let's run it.
The result is here.s
```python
p_factors = [
    2,
    9277,
    16057,
    33223,
    33961,
......
    61837,
    61961,
    62743,
    63577,
    65407,
]

q_factors = [
    2,
    33161,
    48751,
    67391,
    67399,
......
    126227,
    127163,
    127607,
    128047,
]
```

Together with the program, we can see that $p$ and $q$ are constructed by adding $1$ to the product of small prime numbers (if adding $1$ does not result in a prime number, it is reconstructed).

Also, the range of primes used in $p$ and $q$ is different. For this situation, a prime factorization technique called the $p-1$ method can be used.



The $p-1$ method uses the fact that Fermat's little theorem $a^{p-1} = 1 \pmod p$ holds for mutually prime $a,p$.

If we bring the appropriate number $M$ that is a multiple of $p-1$ and compute $a^M$, we have $a^M = 1 \pmod p$ and $a^M-1$ is a multiple of $p$.

That is, by setting the appropriate $M$. 
The GCD of $a^M-1$ and $n$ is $p$.

This time, since $p-1$ is generated by the product of primes less than $10^5$, we choose $M$ as the product of primes less than $10^5$ and $2$ for $a$.


The value of $M$ is not just any product of small prime numbers; if $M$ is a product of prime numbers up to about $1.5\times 10^5$, then $M$ will be a multiple of $(p-1)(q-1)$ and
Since $a^{(p-1)(q-1)} =a^M = 1 \pmod n$, the GCD of $n$ and $a^M-1$ is $n$.

<detial>


<details>
<summary>in Japanese</summary>



`gen.py`にある`DEGUB`を実行し，プログラムも合わせて見ると，$p$と$q$は小さな素数の積に$1$を足して作られていることがわかります(もし$1$を足しても素数にならなければ作り直している)．また，$p$と$q$で使われている素数の範囲も異なっています．この状況に対して，$p-1$法という素因数分解の手法が使えます．

$p-1$法は，互いに素な$a,p$で，フェルマーの小定理$a^{p-1} = 1 \pmod p$が成り立つことを使います．

$p-1$の倍数である適当な数$M$を持ってきて，$a^M$ を計算すれば， $a^M = 1 \pmod p$ が成り立ち， $a^M-1$ が $p$ の倍数となります．

つまり，適当な$M$を設定することで， 
$a^M-1$ と $n$の最大公約数が$p$となります．

今回は，$p-1$が$10^5$未満の素数の積によって生成されていることから，$M$を$10^5$以下の素数の積として，$a$は$2$を選びます．

$M$の値は小さな素数の積であれば何でもいいわけではなく，もし$M$を$1.5\times 10^5$程度までの素数の積にしてしまうと，$M$が$(p-1)(q-1)$の倍数になってしまい，
$a^{(p-1)(q-1)} =a^M = 1 \pmod n$が成り立つため，$n$と$a^M-1$の最大公約数が$n$になってしまいます．

</details>


```
from Crypto.Util.number import *


n = (omitted)
c = (omitted)
e = 0x10001

a = 2
b = 1
for i in range(2,100000):
    if isPrime(i):
        b*=i
ab =pow(a,b,n)

p = GCD(ab-1,n)
q=n//p

phi=(p-1)*(q-1)
d=pow(e,-1,phi)
m=pow(c,d,n)
print(long_to_bytes(m))
```



### Writer
[shiba28](https://twitter.com/Shibak3333n)

### References

この問題を解くにあたって下記の記事を参考にさせていただきました．
https://wacchoz.hatenablog.com/entry/2019/01/20/120000