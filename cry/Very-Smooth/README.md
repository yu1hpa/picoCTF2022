# Very-Smooth

### Solution
First, we try [factordb](http://factordb.com/), but this dosen't work.
so now look at how to make <img src="https://latex.codecogs.com/svg.latex?p" /> and  <img src="https://latex.codecogs.com/svg.latex?q"/>.
there is `DEGUB` in ``gen.py``, let's run it.
The result is here.

```python
p_factors = [
    2,
    9277,
    16057,
    33223,
    33961,
......
    61837,
    61961,
    62743,
    63577,
    65407,
]

q_factors = [
    2,
    33161,
    48751,
    67391,
    67399,
......
    126227,
    127163,
    127607,
    128047,
]
```

Together with the program, we can see that <img src="https://latex.codecogs.com/svg.latex?p" /> and <img src="https://latex.codecogs.com/svg.latex?q" /> are constructed by adding <img src="https://latex.codecogs.com/svg.image?1" /> to the product of small prime numbers (if adding <img src="https://latex.codecogs.com/svg.image?1" /> does not result in a prime number, it is reconstructed).

Also, the range of primes used in <img src="https://latex.codecogs.com/svg.latex?p" /> and <img src="https://latex.codecogs.com/svg.latex?q" /> is different. For this situation, a prime factorization technique called the <img src="https://latex.codecogs.com/svg.latex?p-1" /> method can be used.



The <img src="https://latex.codecogs.com/svg.latex?p-1" /> method uses the fact that Fermat's little theorem <img src="https://latex.codecogs.com/svg.image?a^{p-1}&space;=&space;1&space;\pmod&space;p" /> holds for mutually prime $a,p$.

If we bring the appropriate number <img src="https://latex.codecogs.com/svg.image?M" /> that is a multiple of <img src="https://latex.codecogs.com/svg.latex?p-1" /> and compute <img src="https://latex.codecogs.com/svg.image?a^M"/>, we have <img src="https://latex.codecogs.com/svg.image?a^M&space;=&space;1&space;\pmod&space;p"/> and <img src="https://latex.codecogs.com/svg.image?a^M-1" /> is a multiple of <img src="https://latex.codecogs.com/svg.latex?p"/>.

That is, by setting the appropriate <img src="https://latex.codecogs.com/svg.image?M"/>. 
The GCD of <img src="https://latex.codecogs.com/svg.image?a^M-1" /> and <img src="https://latex.codecogs.com/svg.image?n" /> is <img src="https://latex.codecogs.com/svg.latex?p"/>.

This time, since <img src="https://latex.codecogs.com/svg.latex?p-1" /> is generated by the product of primes less than <img src="https://latex.codecogs.com/svg.image?10^5"/>, we choose <img src="https://latex.codecogs.com/svg.image?M" /> as the product of primes less than <img src="https://latex.codecogs.com/svg.image?10^5" /> and <img src="https://latex.codecogs.com/svg.image?2" /> for <img src="https://latex.codecogs.com/svg.image?a"/>.


The value of <img src="https://latex.codecogs.com/svg.image?M" /> is not just any product of small prime numbers; if <img src="https://latex.codecogs.com/svg.image?M" /> is a product of prime numbers up to about <img src="https://latex.codecogs.com/svg.image?1.5\times&space;10^5"/>), then <img src="https://latex.codecogs.com/svg.image?M" /> will be a multiple of <img src="https://latex.codecogs.com/svg.image?(p-1)(q-1)" /> and
Since <img src="https://latex.codecogs.com/svg.image?a^{(p-1)(q-1)}&space;=a^M&space;=&space;1&space;\pmod&space;n"/>, the GCD of <img src="https://latex.codecogs.com/svg.image?n" /> and <img src="https://latex.codecogs.com/svg.image?a^M-1" /> is <img src="https://latex.codecogs.com/svg.image?n"/>.

<detial>


<details>
<summary>日本語 (in Japanese)</summary>



`gen.py`にある`DEGUB`を実行し，プログラムも合わせて見ると，<img src="https://latex.codecogs.com/svg.latex?p" />と<img src="https://latex.codecogs.com/svg.latex?q" />は小さな素数の積に<img src="https://latex.codecogs.com/svg.image?1" />を足して作られていることがわかります(もし<img src="https://latex.codecogs.com/svg.image?1" />を足しても素数にならなければ作り直している")．また，<img src="https://latex.codecogs.com/svg.latex?p" />と<img src="https://latex.codecogs.com/svg.latex?q" />で使われている素数の範囲も異なっています．この状況に対して，<img src="https://latex.codecogs.com/svg.latex?p-1" />法という素因数分解の手法が使えます．

<img src="https://latex.codecogs.com/svg.latex?p-1" />法は，互いに素な$a,p$で，フェルマーの小定理<img src="https://latex.codecogs.com/svg.image?a^{p-1}&space;=&space;1&space;\pmod&space;p" />が成り立つことを使います．

<img src="https://latex.codecogs.com/svg.latex?p-1" />の倍数である適当な数<img src="https://latex.codecogs.com/svg.image?M" />を持ってきて，<img src="https://latex.codecogs.com/svg.image?a^M"/> を計算すれば， <img src="https://latex.codecogs.com/svg.image?a^M&space;=&space;1&space;\pmod&space;p" /> が成り立ち， <img src="https://latex.codecogs.com/svg.image?a^M-1" /> が <img src="https://latex.codecogs.com/svg.latex?p" /> の倍数となります．

つまり，適当な<img src="https://latex.codecogs.com/svg.image?M" />を設定することで， 
<img src="https://latex.codecogs.com/svg.image?a^M-1" /> と <img src="https://latex.codecogs.com/svg.image?n" />の最大公約数が<img src="https://latex.codecogs.com/svg.latex?p" />となります．

今回は，<img src="https://latex.codecogs.com/svg.latex?p-1" />が<img src="https://latex.codecogs.com/svg.image?10^5" />未満の素数の積によって生成されていることから，<img src="https://latex.codecogs.com/svg.image?M" />を<img src="https://latex.codecogs.com/svg.image?10^5" />以下の素数の積として，<img src="https://latex.codecogs.com/svg.image?a" />は<img src="https://latex.codecogs.com/svg.image?2" />を選びます．

<img src="https://latex.codecogs.com/svg.image?M" />の値は小さな素数の積であれば何でもいいわけではなく，もし<img src="https://latex.codecogs.com/svg.image?M" />を<img src="https://latex.codecogs.com/svg.image?1.5\times&space;10^5" />程度までの素数の積にしてしまうと，<img src="https://latex.codecogs.com/svg.image?M"/>が<img src="https://latex.codecogs.com/svg.image?(p-1)(q-1))"/>の倍数になってしまい，
<img src="https://latex.codecogs.com/svg.image?a^{(p-1)(q-1)}&space;=a^M&space;=&space;1&space;\pmod&space;n)"/>が成り立つため，<img src="https://latex.codecogs.com/svg.image?n"/>)と<img src="https://latex.codecogs.com/svg.image?a^M-1"/>)の最大公約数が<img src="https://latex.codecogs.com/svg.image?n"/>になってしまいます．

</details>


```
from Crypto.Util.number import *


n = (omitted)
c = (omitted)
e = 0x10001

a = 2
b = 1
for i in range(2,100000):
    if isPrime(i):
        b*=i
ab =pow(a,b,n)

p = GCD(ab-1,n)
q=n//p

phi=(p-1)*(q-1)
d=pow(e,-1,phi)
m=pow(c,d,n)
print(long_to_bytes(m))
```



### Writer
[shiba28](https://twitter.com/Shibak3333n)

### References

この問題を解くにあたって下記の記事を参考にさせていただきました．

https://wacchoz.hatenablog.com/entry/2019/01/20/120000